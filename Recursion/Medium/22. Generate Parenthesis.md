---
dsa-patterns: 
- '[[Recursion]]'
- '[[binary trees and binary search trees]]'
difficulty: medium
companies: 
- Amazon
- Google
- Apple 
- Microsoft
- Facebook
dg-publish: true
---
# Problem Definition

**Leetcode Link:** [Generate Parenthesis](https://leetcode.com/problems/generate-parentheses/description/)
**Solution Link:** [Neetcode](https://www.youtube.com/watch?v=s9fokUqJ76A) 

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example 1:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```

Example 2:
```
Input: n = 1
Output: ["()"]
```

# Approach 

- It is clearly a recursion problem.
- In my initial solution/approach, I mapped out the decision tree for the generation of the valid pairs.
- In which I noticed 3 scenarios, I started with op = n, cl = n
1. op == cl then you can add only opening bracket
2. op == 0 then you can add only closing bracket
3. cl > op then you can add both opening & closing bracket as 2 sub-scenarios
- Where I went wrong was I didn't make sure to check if op went below 0 and for the condition cl > op, as op was goin below 0 it went on an infinite loop.

![alt text](DSA-Problems/Recursion/Medium/image.png)

```python
def generate(op, cl, combi):
    if op == 0 and cl == 0:
        res.append(combi)
        return
    if cl == op:
        generate(op - 1, cl, combi + '(')
    if op == 0:
        generate(op, cl - 1, combi + ')')
    if cl > op:
        generate(op - 1, cl, combi + '(')
        generate(op, cl - 1, combi + ')')
res = []
generate(n, n, "")
return res
```

- For the optimal approach we need to make some changes.
- We know there are two scenarios:
1. When you have opening brackets to spare i.e op > 0 you can add opening bracket
2. When you have more closing than opening i.e cl > op you can add closing brackets
- At every level of the tree we have two options: the conditions above.

![alt text](DSA-Problems/Recursion/Medium/image-1.png)

# Solution

**Time Complexity:** 
**Space Complexity:**

```python
def generate(op, cl, combi):
    if op == cl == 0:
        res.append(combi)
        return
    if op > 0:
        generate(op - 1, cl, combi + "(")
    if cl > op:
        generate(op, cl - 1, combi + ")")
res = []
generate(n, n, "")
return res
```