# Problem Definition

**Leetcode Link:** [3Sum](https://leetcode.com/problems/3sum/submissions/1366345932/)
**Solution Link:** [3Sum Neetcode](https://www.youtube.com/watch?v=jzZsG8n2R9A)

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

Example 1:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

Example 2:
```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

Example 3:
```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

# Approach

Honestly this is not a easy problem. I'll go with what I did first like my solutions at the start and then explain the approach for the optimal.

**First Solution:**
- To use a Hashmap. As we know that if we fix one element as the first element in the triplet then for finding the 2 numbers it would be a 2Sum problem.
- So I created a Hashmap as element:index pairs.
- After I created a Hashmap we need to run an outer loop from 1st element to last element and an inner loop that checks for 2Sum from i+1 to last element.
- For appending the triplets to result list, I had to make sure I was appending the sorted triplets and check if it was not already there in the list.
- This solution passes `309/313` test cases and I got a time limit exceeded error.

**Second Solution:**
- I was looking through the discussions and saw a tip where they mentioned:
> 1. Sort the given array in non-decreasing order.
> 2. Loop through the array from index 0 to n-1.
> 3. For each iteration, set the target as -nums[i].
> 4. Set two pointers, j=i+1 and k=n-1.
> 5. While j<k, check if nums[j]+nums[k]==target.
> 6. If yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.
> 7. If no, move either j or k based on the comparison of nums[j]+nums[k] with target.
> 8. To avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also > skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].

- I implemented this but I overlooked the fact that to avoid duplicates I should also check when I'm updating the j and k, due to which it only passes `311/313` test cases and time limit exceeded.

**Optimal Solution:**
- I just had to take action for duplicates while updating j and k. I need to skip the elements that are same. 

# Solution

**Time Complexity:** O(n^2)
**Space Complexity:** O(1)

```python
res = []
nums.sort()
for i, x in enumerate(nums):
    if i > 0 and nums[i] == nums[i-1]:
        continue
    l = i + 1
    r = len(nums) - 1
    while l < r:
        sum = x + nums[l] + nums[r]
        if sum < 0:
            l += 1
        elif sum > 0:
            r -= 1
        else:
            res.append([x, nums[l], nums[r]])
            l += 1
            while nums[l] == nums[l-1] and l < r:
                l += 1
return res
```