# Problem Definition

**Concepts:** `Hash-Map`
**Link:** [Leetcode](https://leetcode.com/problems/two-sum/description/)

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

    Input: nums = [2,7,11,15], target = 9
    Output: [0,1]
    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

    Input: nums = [3,2,4], target = 6
    Output: [1,2]

Example 3:

    Input: nums = [3,3], target = 6
    Output: [0,1]

Constraints:

    2 <= nums.length <= 104
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    Only one valid answer exists.

# Approach

The problem is to find two numbers whose sum is equal to the target. I did a mistake of not noticing the constraints where they tell `only one valid answer exists`

## Brute Force

Run a nested for loop and find the right pair. This would take O(n^2) time.

## Better

We can use a hashmap. We can store the elements in hashmap in the format: `element : index` pairs. After that iterate through the array to find a element in hashmap such that it is equal to the `target - cur`. 

What I was worried when I got this idea to my mind was, how to manage duplicates but we can notice that they have told that only one valid answer exists and if one of the duplicates could be the answer then the other one would be the duplicate itself.

This approach was a 2 pass solution where:
Pass-1: Add elements to hashmap
Pass-2: Check and search for pair

## Optimal 

Is the same as above approach but we finish the solution in one pass. We check if the element is in hashmap first, if so we'll return if not we'll add the current element to hashmap and continue the search.

# Code

**Time Complexity:** O(N)

**Space Complexity:** O(N)

```python
def 2Sum(nums: List[int], target: int) -> List[int]:
    map = {}
    if nums[0] + nums[1] == target:
        return [0, 1]
    for i, num in enumerate(nums):
        second = target - num
        if second in map:
            return [i, map[second]]
        map[num] = i
```